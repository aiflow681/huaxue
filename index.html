<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æˆ·å¤–æ»‘é›ª (Pure H5)</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f0f8ff;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UIå±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .header-panel {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .score-board {
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 24px;
            font-weight: bold;
            backdrop-filter: blur(5px);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .controls-panel {
            padding: 10px 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto;
        }

        /* è™šæ‹ŸæŒ‰é’® */
        .btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.6);
            color: white;
            font-size: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
            user-select: none;
            transition: transform 0.1s, background 0.1s;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .btn:active, .btn.active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.4);
        }

        .btn-restart {
            position: absolute;
            left: 50%;
            bottom: 30px;
            transform: translateX(-50%);
            display: none;
        }
        
        .btn-restart.visible {
            display: flex;
        }

        /* æ¸¸æˆç»“æŸç•Œé¢ */
        .game-over-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            display: none;
            pointer-events: auto;
            min-width: 250px;
        }

        .game-over-modal.active {
            display: block;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .game-over-modal h2 {
            margin: 0 0 10px;
            color: #333;
            font-size: 32px;
        }

        .game-over-modal .final-score {
            font-size: 48px;
            font-weight: bold;
            color: #e74c3c;
            margin: 10px 0 20px;
        }

        .game-over-modal .hint {
            color: #7f8c8d;
            font-size: 14px;
            margin-bottom: 20px;
        }

        .restart-action-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            width: 100%;
            font-family: inherit;
        }

        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
            to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            .btn { width: 70px; height: 70px; font-size: 28px; }
            .score-board { font-size: 20px; padding: 8px 16px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="header-panel">
            <div class="score-board">å¾—åˆ†: <span id="scoreDisplay">0</span></div>
        </div>

        <div class="controls-panel" id="controlsPanel">
            <div class="btn" id="leftBtn">â¬…ï¸</div>
            <div class="btn btn-restart" id="centerRestartBtn">ğŸ”„</div>
            <div class="btn" id="rightBtn">â¡ï¸</div>
        </div>
    </div>

    <div class="game-over-modal" id="gameOverModal">
        <h2>æ¸¸æˆç»“æŸ</h2>
        <div class="hint">æ’åˆ°æ ‘äº†!</div>
        <div class="final-score" id="finalScoreDisplay">0</div>
        <button class="restart-action-btn" id="modalRestartBtn">é‡æ–°å¼€å§‹</button>
    </div>

<script>
// æ¸¸æˆé…ç½®
const CONFIG = {
    playerSpeed: 300,           // ç©å®¶ç§»åŠ¨é€Ÿåº¦
    baseObjectSpeed: 200,       // éšœç¢ç‰©åŸºç¡€é€Ÿåº¦
    speedIncrRate: 5,           // é€Ÿåº¦å¢é•¿ç‡
    maxSpeed: 800,              // æœ€å¤§é€Ÿåº¦
    spawnRate: 5.0,             // éšœç¢ç‰©ç”Ÿæˆé¢‘ç‡
    treeWidth: 40,              // æ ‘æœ¨å®½åº¦
    treeHeight: 60,             // æ ‘æœ¨é«˜åº¦
    playerWidth: 30,            // ç©å®¶å®½åº¦
    playerHeight: 40            // ç©å®¶é«˜åº¦
};

// æ¸¸æˆçŠ¶æ€
const state = {
    isRunning: false,           // æ¸¸æˆæ˜¯å¦è¿è¡Œä¸­
    isGameOver: false,          // æ¸¸æˆæ˜¯å¦ç»“æŸ
    score: 0,                   // å½“å‰å¾—åˆ†
    speed: CONFIG.baseObjectSpeed,  // å½“å‰é€Ÿåº¦
    lastTime: 0,                // ä¸Šä¸€å¸§æ—¶é—´
    objects: [],                // éšœç¢ç‰©æ•°ç»„
    particles: [],              // ç²’å­æ•ˆæœæ•°ç»„
    player: {
        x: 0,                   // ç©å®¶Xåæ ‡
        y: 150,                 // ç©å®¶Yåæ ‡
        direction: 0            // ç©å®¶æ–¹å‘ï¼ˆ-1å·¦ï¼Œ0ä¸­ï¼Œ1å³ï¼‰
    },
    inputs: {
        left: false,            // å·¦é”®æ˜¯å¦æŒ‰ä¸‹
        right: false            // å³é”®æ˜¯å¦æŒ‰ä¸‹
    }
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreDisplay = document.getElementById('scoreDisplay');
const gameOverModal = document.getElementById('gameOverModal');
const finalScoreDisplay = document.getElementById('finalScoreDisplay');
const centerRestartBtn = document.getElementById('centerRestartBtn');

let animationFrameId;  // åŠ¨ç”»å¸§ID
let width, height;     // ç”»å¸ƒå®½é«˜

// åˆå§‹åŒ–æ¸¸æˆ
function init() {
    resize();
    window.addEventListener('resize', resize);
    setupInputs();
    resetGame();
    requestAnimationFrame(gameLoop);
}

// è°ƒæ•´ç”»å¸ƒå¤§å°
// è°ƒæ•´ç”»å¸ƒå¤§å°
function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    // é¦–æ¬¡åŠ è½½æ—¶å±…ä¸­ç©å®¶
    if (!state.isRunning && state.score === 0) {
        state.player.x = width / 2;
    }
}

// é‡ç½®æ¸¸æˆçŠ¶æ€
// é‡ç½®æ¸¸æˆçŠ¶æ€
function resetGame() {
    state.isRunning = true;
    state.isGameOver = false;
    state.score = 0;
    state.speed = CONFIG.baseObjectSpeed;
    state.objects = [];
    state.particles = [];
    state.player.x = width / 2;
    state.player.direction = 0;
    
    state.inputs.left = false;
    state.inputs.right = false;

    scoreDisplay.innerText = "0";
    gameOverModal.classList.remove('active');
    centerRestartBtn.classList.remove('visible');
    
    state.lastTime = performance.now();
}

// æ¸¸æˆç»“æŸå¤„ç†
// æ¸¸æˆç»“æŸå¤„ç†
function gameOver() {
    state.isRunning = false;
    state.isGameOver = true;
    
    finalScoreDisplay.innerText = Math.floor(state.score);
    gameOverModal.classList.add('active');
    centerRestartBtn.classList.add('visible');
}

// è®¾ç½®è¾“å…¥æ§åˆ¶
function setupInputs() {
    // é”®ç›˜æ§åˆ¶
    window.addEventListener('keydown', (e) => {
        if (e.code === 'ArrowLeft') state.inputs.left = true;
        if (e.code === 'ArrowRight') state.inputs.right = true;
        if (e.code === 'Enter' && state.isGameOver) resetGame();
    });
    
    window.addEventListener('keyup', (e) => {
        if (e.code === 'ArrowLeft') state.inputs.left = false;
        if (e.code === 'ArrowRight') state.inputs.right = false;
    });

    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const modalRestartBtn = document.getElementById('modalRestartBtn');

    // ç»‘å®šæŒ‰é’®äº‹ä»¶
    const bindBtn = (elem, inputKey) => {
        const start = (e) => { e.preventDefault(); state.inputs[inputKey] = true; elem.classList.add('active'); };
        const end = (e) => { e.preventDefault(); state.inputs[inputKey] = false; elem.classList.remove('active'); };
        
        elem.addEventListener('mousedown', start);
        elem.addEventListener('touchstart', start);
        elem.addEventListener('mouseup', end);
        elem.addEventListener('touchend', end);
        elem.addEventListener('mouseleave', end);
    };

    bindBtn(leftBtn, 'left');
    bindBtn(rightBtn, 'right');

    // é‡æ–°å¼€å§‹æŒ‰é’®
    const restartAction = (e) => {
        e.preventDefault();
        resetGame();
    };

    modalRestartBtn.addEventListener('click', restartAction);
    modalRestartBtn.addEventListener('touchstart', restartAction);
    centerRestartBtn.addEventListener('click', restartAction);
    centerRestartBtn.addEventListener('touchstart', restartAction);
}

// æ›´æ–°æ¸¸æˆé€»è¾‘
function update(dt) {
    if (!state.isRunning) return;

    // é€æ¸å¢åŠ éš¾åº¦
    if (state.speed < CONFIG.maxSpeed) {
        state.speed += CONFIG.speedIncrRate * dt;
    }
    
    // æ ¹æ®é€Ÿåº¦è®¡ç®—å¾—åˆ†
    state.score += (state.speed * dt) / 10;
    scoreDisplay.innerText = Math.floor(state.score);

    // å¤„ç†ç©å®¶ç§»åŠ¨
    const moveSpeed = CONFIG.playerSpeed * dt;
    if (state.inputs.left) {
        state.player.x -= moveSpeed;
        state.player.direction = -1;
    } else if (state.inputs.right) {
        state.player.x += moveSpeed;
        state.player.direction = 1;
    } else {
        state.player.direction = 0;
    }

    // é™åˆ¶ç©å®¶åœ¨å±å¹•å†…
    if (state.player.x < 20) state.player.x = 20;
    if (state.player.x > width - 20) state.player.x = width - 20;

    // éšæœºç”Ÿæˆéšœç¢ç‰©
    const spawnChance = CONFIG.spawnRate * dt;
    if (Math.random() < spawnChance) {
        spawnObject();
    }
    
    // ç¡®ä¿è‡³å°‘æœ‰ä¸€ä¸ªéšœç¢ç‰©
    if (state.objects.length === 0 && Math.random() < 0.1) spawnObject();

    // æ›´æ–°æ‰€æœ‰éšœç¢ç‰©ä½ç½®
    const distanceMoved = state.speed * dt;
    
    for (let i = state.objects.length - 1; i >= 0; i--) {
        const obj = state.objects[i];
        obj.y -= distanceMoved;
        
        // ç§»é™¤å·²ç»ç¦»å¼€å±å¹•çš„éšœç¢ç‰©
        if (obj.y < -100) {
            state.objects.splice(i, 1);
            continue;
        }

        // æ£€æµ‹ç¢°æ’
        const px = state.player.x - CONFIG.playerWidth / 2;
        const py = state.player.y - CONFIG.playerHeight;
        const pw = CONFIG.playerWidth;
        const ph = CONFIG.playerHeight;

        const tx = obj.x - obj.width / 4;
        const ty = obj.y - obj.height/2; 
        const tw = obj.width / 2;
        const th = obj.height/2;

        // å¦‚æœå‘ç”Ÿç¢°æ’ï¼Œæ¸¸æˆç»“æŸ
        if (rectIntersect(px, py, pw, ph, tx, ty, tw, th)) {
            createCrashParticles(state.player.x, state.player.y);
            gameOver();
        }
    }
    
    // ç”Ÿæˆæ»‘é›ªè½¨è¿¹ç²’å­
    if (state.isRunning && Math.random() < 0.3) {
        state.particles.push({
            x: state.player.x + (Math.random() * 10 - 5),
            y: state.player.y,
            life: 1.0,
            type: 'trail'
        });
    }

    // æ›´æ–°ç²’å­æ•ˆæœ
    for (let i = state.particles.length - 1; i >= 0; i--) {
        const p = state.particles[i];
        p.life -= dt;
        p.y -= distanceMoved;
        if (p.life <= 0) {
            state.particles.splice(i, 1);
        }
    }
}

// ç”Ÿæˆæ–°çš„éšœç¢ç‰©
function spawnObject() {
    const type = Math.random() < 0.8 ? 'tree' : 'rock';  // 80%æ¦‚ç‡ç”Ÿæˆæ ‘ï¼Œ20%ç”ŸæˆçŸ³å¤´
    state.objects.push({
        x: Math.random() * (width - 40) + 20,
        y: height + 50,
        type: type,
        width: CONFIG.treeWidth,
        height: CONFIG.treeHeight
    });
}

// çŸ©å½¢ç¢°æ’æ£€æµ‹
function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

// åˆ›å»ºç¢°æ’çˆ†ç‚¸ç²’å­æ•ˆæœ
function createCrashParticles(x, y) {
    for (let i = 0; i < 20; i++) {
        state.particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 200,
            vy: (Math.random() - 0.5) * 200,
            life: 1.0,
            color: 'white',
            type: 'crash'
        });
    }
}

// æ¸²æŸ“æ¸¸æˆç”»é¢
function draw() {
    // ç»˜åˆ¶æ¸å˜èƒŒæ™¯
    ctx.fillStyle = '#87CEEB';
    const gradient = ctx.createLinearGradient(0, 0, 0, height);
    gradient.addColorStop(0, '#E0F7FA'); 
    gradient.addColorStop(1, '#B2EBF2');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, width, height);

    // ç»˜åˆ¶é›ªèŠ±è½¨è¿¹ç²’å­
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    state.particles.forEach(p => {
        if (p.type === 'trail') {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
        } else if (p.type === 'crash') {
            // ç¢°æ’ç²’å­å¸¦æœ‰é€Ÿåº¦
            p.x += p.vx * 0.016;
            p.y += p.vy * 0.016;
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    });

    // æŒ‰Yåæ ‡æ’åºï¼Œå®ç°è¿‘å¤§è¿œå°æ•ˆæœ
    state.objects.sort((a, b) => a.y - b.y);

    // ç»˜åˆ¶æ‰€æœ‰éšœç¢ç‰©
    state.objects.forEach(obj => {
        if (obj.type === 'tree') {
            drawTree(ctx, obj.x, obj.y, obj.width, obj.height);
        } else {
            drawRock(ctx, obj.x, obj.y);
        }
    });

    // æ ¹æ®æ¸¸æˆçŠ¶æ€ç»˜åˆ¶ç©å®¶
    if (state.isRunning) {
        drawPlayer(ctx, state.player.x, state.player.y, state.player.direction);
    } else if (state.isGameOver) {
        drawPlayerCrashed(ctx, state.player.x, state.player.y);
    }
}

// ç»˜åˆ¶æ ‘æœ¨éšœç¢ç‰©
function drawTree(ctx, x, y, w, h) {
    // ç»˜åˆ¶é˜´å½±
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.beginPath();
    ctx.ellipse(x, y, w/2, 5, 0, 0, Math.PI*2);
    ctx.fill();

    // ç»˜åˆ¶æ ‘å¹²
    ctx.fillStyle = '#5D4037';
    ctx.fillRect(x - 4, y - 10, 8, 10);

    // ç»˜åˆ¶æ ‘å¶ï¼ˆä¸¤å±‚ä¸‰è§’å½¢ï¼‰
    ctx.fillStyle = '#2E7D32';
    ctx.beginPath();
    ctx.moveTo(x - w/2, y - 5);
    ctx.lineTo(x + w/2, y - 5);
    ctx.lineTo(x, y - h * 0.6);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(x - w/3, y - h * 0.4);
    ctx.lineTo(x + w/3, y - h * 0.4);
    ctx.lineTo(x, y - h);
    ctx.fill();
    
    // ç»˜åˆ¶æ ‘é¡¶ç§¯é›ª
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.moveTo(x, y - h);
    ctx.lineTo(x - 5, y - h + 10);
    ctx.lineTo(x + 5, y - h + 10);
    ctx.fill();
}

// ç»˜åˆ¶çŸ³å¤´éšœç¢ç‰©
function drawRock(ctx, x, y) {
    ctx.fillStyle = '#9E9E9E';
    ctx.beginPath();
    ctx.arc(x, y - 5, 10, 0, Math.PI, true);
    ctx.fill();
}

// ç»˜åˆ¶æ­£å¸¸æ»‘é›ªçš„ç©å®¶
function drawPlayer(ctx, x, y, dir) {
    ctx.save();
    ctx.translate(x, y);
    
    // æ ¹æ®ç§»åŠ¨æ–¹å‘æ—‹è½¬
    const rotation = dir * 20 * (Math.PI / 180);
    ctx.rotate(rotation);

    // ç»˜åˆ¶æ»‘é›ªæ¿
    ctx.fillStyle = '#B71C1C';
    ctx.fillRect(-10, -5, 5, 20);
    ctx.fillRect(5, -5, 5, 20);

    // ç»˜åˆ¶èº«ä½“
    ctx.fillStyle = '#1565C0';
    ctx.beginPath();
    ctx.arc(0, -15, 8, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillRect(-6, -10, 12, 10);

    // ç»˜åˆ¶å›´å·¾
    ctx.strokeStyle = '#FFEB3B';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, -10);
    ctx.lineTo(8, -12);
    ctx.stroke();

    ctx.restore();
}

// ç»˜åˆ¶æ‘”å€’çŠ¶æ€çš„ç©å®¶
function drawPlayerCrashed(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(Math.PI / 2);  // æ¨ªå‘å€’ä¸‹
    
    // ç»˜åˆ¶äº¤å‰çš„æ»‘é›ªæ¿
    ctx.fillStyle = '#B71C1C';
    ctx.save();
    ctx.rotate(Math.PI / 4);
    ctx.fillRect(-15, -2, 30, 4);
    ctx.restore();
    ctx.save();
    ctx.rotate(-Math.PI / 4);
    ctx.fillRect(-15, -2, 30, 4);
    ctx.restore();

    // ç»˜åˆ¶å€’åœ°çš„èº«ä½“
    ctx.fillStyle = '#1565C0';
    ctx.beginPath();
    ctx.arc(10, 0, 8, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
}

// æ¸¸æˆä¸»å¾ªç¯
function gameLoop(time) {
    const dt = (time - state.lastTime) / 1000;  // è®¡ç®—æ—¶é—´å·®ï¼ˆç§’ï¼‰
    state.lastTime = time;

    update(dt);  // æ›´æ–°æ¸¸æˆé€»è¾‘
    draw();      // æ¸²æŸ“ç”»é¢

    animationFrameId = requestAnimationFrame(gameLoop);
}

init();

</script>
</body>
</html>
